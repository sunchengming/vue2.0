Vue的核心理念是数据驱动的理念，所谓的数据驱动的理念：当数据发生变化的时候，用户界面也会发生相应的变化，开发者并不需要手动
的去修改dom
Vue的响应式原理
当创建 Vue 实例时,vue 会遍历 data 选项的属性,利用Object.defineProperty为属性添加 getter和setter 对数据的读取进行劫持（getter
用来依赖收集,setter 用来派发更新）,并且在内部追踪依赖,在属性被访问和修改时通知变化


前端页面优化
html:在线网站进行压缩 html-minifier工具
css 　css语义合并;  在线网站进行压缩 html-minifier对html中的css进行压缩
js html-minifier工具  在线网站进行压缩 代码语义的缩减和优化 剔除注释; 　无效字符的删除(空格，回车等);
img Base64->转换 雪碧图

前端项目打包优化
nodejs提供的html-minifier工具压缩
代码压缩：vue中configs中引入echarts
cdn引入：哪个页面需要用到，就按照上面的引入就行，也可以在main.js全局引入，这样就可以直接使用echarts.init()等方法了
CDN全称Content Delivery Network（内容分发网络）
把一些静态资源：css， .js，图片，视频放在第三方的CDN服务器上，可以加速访问速度
按需引入：
懒加载：
压缩文件：compression-webpack-plugin

前端浏览器缓存机制：
浏览器缓存处于服务器和客户端之间
浏览器缓存有哪些优势
1、把文件保存在了客户端，减少重复请求浪费网络带宽；
（ps:带宽就是在一段时间内可通过互联网提供商传输的最大数据量。）
2、有效的缓解了服务器的压力，不用重复请求数据；
3、提高了访问速度，用户体验感更佳；

浏览器缓存过程：浏览器先获取该资源缓存的header信息，根据其中的expires和cahe-control判断是否命中强缓存

防抖：连续多次触发事件只执行一个函数，用到setTimeout 和clearTimeout
节流：指连续触发事件但是在 n 秒中只执行一次函数。 let timer = null   timer = null; //开

基本数据类型：
number string boolean undefiend null
引用类型：
Object：array，function
Symbol类型作为对象的私有属性，通过for/in、for/of无法遍历
const TYPE_AUDIO = Symbol()


变量作用域 var let const
1.使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象。
2.使用let声明的变量，其作用域为该语句所在的代码块内，不存在变量提升。
3.使用const声明的是常量，在后面出现的代码中不能再修改该常量的值,常用来声明函数等。

代码空间是存储执行代码的，栈空间是存储执行上下文的，堆空间存储对象的。
堆(heap):由操作系统动态分配的内存，大小不定也不会自动释放，一般由程序员分配释放，也可由垃圾回收机制回收（程序结束时由浏览器回收）。
栈(stack):由操作系统自动分配内存空间，自动释放，存储的是基础变量以及一些对象的引用变量，占据固定大小的空间
栈空间的内存比较小，但是运行和存储快，内存值是固定的。 栈是一种运算受限的线性表，其限制是指只仅允许在表的一端进行插入和删除操作
堆空间呢内存是根据存储内容自适配的，运行读取比较慢。
垃圾回收机制：
如果栈中不存在对堆中某个对象的引用，那么就认为该对象已经不再需要，在垃圾回收时就会清除该对象占用的内存空间

js的执行机制
JavaScript是一门单线程语言，js需要异步任务
js事件循环是怎样运作的：
macro-task(宏任务)：包括整体代码script，setTimeout，setInterval
micro-task(微任务)：Promise，process.nextTick

什么是闭包
闭包就是能够读取其他函数内部变量的函数
function a() {
    let x = 2;
    return function() {
        console.log(x);
    }
}
let func = a();
func()

vue中：
组件 (Component) 是用来构成你的 App 的业务模块，它的目标是 App.vue。
插件 (Plugin) 是用来增强你的技术栈的功能模块，它的目标是 Vue 本身。
vue.component("component",{
    props:[],
    data:{},
    template:""
})
import 'my-component' from 'xxx/xxx/xxx'
export default {
components:{ myCom }
}

var VueRouter = require('vue-router')
Vue.use('VueRouter')


构造选项options
⑴什么是构造选项options
当我们调用一个Vue实例时，返回的并不是对象本身而是一个可以操作这个元素的方法和属性的API对象。其中options代表的就是。
const vm = new Vue(options);  /这就是一个Vue实例 前面变量声明可以不写 参数options就是构造选项
其中vm就是Vue实例的别称，这个是Vue作者推荐的，我觉得可以参考 MVVM模型1中的VM。


⑵五类最常见的options
①数据：data、props、propsData、computed、methods、watch。
②DOM：el、template、render、renderError。
③生命周期钩子(函数): beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、activated、deactivated、beforeDestroy、destroyed，errorCaptured。
④资源：directives、filters、components。
⑤组合：parent、mixins、extends、provide、inject。

Vue2.0数据绑定:Vue2.0使用Object.defineProperty
Vue3.0数据绑定:通过ES6的新特性proxy来劫持数据，当数据改变时发出通知
使用proxy不污染源对象，会返回一个新对象，defineProperty是注入型的，会破坏源对象。
使用proxy只需要监听整个源对象的属性，不需要循环使用Object.definedProperty监听对象的属性。
使用proxy可以获取到对象属性的更多参数，使用definedProperty只能获取到监听属性的新值newValue。

npm uninstall -g vue-cli  //2.0
npm install -g @vue/cli  //3.0

vue init webpack cli2-test
vue create vue3.0

2.0与3.0生命周期函数比较：
2.0 周期名称 3.0 周期名称
说明:
beforeCreate setup 组件创建之前
created setup 组件创建完成
beforeMount onBeforeMount 组件挂载之前
mounted onMounted 组件挂载完成
beforeUpdate onBeforeUpdate 数据更新，虚拟 DOM 打补丁之前
updated  onUpdated 数据更新，虚拟 DOM 渲染完成
beforeDestroy onBeforeUnmount 组件销毁之前
destroyed onUnmounted 组件销毁后

import { value, computed, watch, onMounted, ref } from 'vue'
export default {
  setup() {
    // ref state
    const count = ref(0)
    // computed state
    const plusOne = computed(() => count.value + 1)
    // method
    const increment = () => { count.value++ }
    // watch
    watch(() => count.value * 2, val => {
      console.log(`count * 2 is ${val}`)
    })
    // lifecycle
    onMounted(() => {
      console.log(`mounted`)
    })
    // expose bindings on render context
    return {
      count,
      plusOne,
      increment
    }
  }
}


语法方面：
v-model语法糖废弃，改用modelValue
弃用全局APInew Vue,使用createApp const app =?Vue.createApp({})
const app = Vue.createApp({})
app.config.globalProperties.$http = () => {}
需要手动挂载根节点：
import { createApp } from 'vue'
import App from './App.vue'
createApp(App).mount('#app')
不能再使用Vue.nextTick/this.$nextTick，Vue3中你可以用：
import { nextTick } from 'vue'
nextTick(() => {
  // something
})


webpack的主要功能是？
提供友好的前端模块化开发，以及代码压缩混淆、处理浏览器端javaScript的兼容性、性能优化等强大功能
好处：把工作的重心集中到具体功能实现上，提高前端开发效率以及项目的可维护性。


webpack.config.js是webpack的配置文件，基于node.js开发出来的打包工具，在打包之前会先读取这个配置文件，基于配置进行打包

最常见的webpack插件如下：webpack-dev-server 每当修改源代码、webpack会监听项目源代码的变化，从而自动进行打包和构建

页面缓存的坑。有个填写信息的页面，需要填写一部分信息，进入查新协议页面，返回的时候，页面上填写的信息还需要留存。  解决
办法：使用vue提供的keep-alive，来完成页面的缓存的

axios请求中post请求的坑
设置请求头里的'Content-Type'为'application/x-www-form-urlencoded'

vue组件中如何获取dom元素？
使用ref属性获取，在组件模板元素中添加ref属性，在js中使用this.$ref获取

vue循环中为什么要是用key
每次循环中要是用key给每个节点做唯一标识，保证一个循环中key的值各不相同

vue组件配置对象中都偶有那些常用字段？分别是什么作用？
data 组建中的数据
props 组件的属性数据，接受父组件的传值
computed 计算属性
components 定义或引用子组件
methods 自定义函数
watch 属性监听
filters 数据过滤器
mounted 生命周期函数


vue路由的钩子函数有哪些？
全聚德路由钩子函数：beforeEach ,afterEach
单个的路由狗子函数：beforeEnter
组件内的路由钩子函数：beforeRouteEnter ，beforeRouteleave ，beforeRouteUpdate

elementUI相对vant而言少了一些东西，例如：

elementUI的默认单位也是px，但它没有提供相应的方法将px转化成rem进行适配。
elementUI没有底部安全区适配等解决方式。
相对vant而言，elementUI少了许多组件，例如：骨架屏、数字键盘、遮罩层、倒计时、滑动单元格等等。
vuex是一个转为vue.js应用程序开发状态管理模式
5个核心属性：
state：数据存放
getters:相当于计算属性
mutation：同步操作，修改数据
action:异步操作
modules；模块化

vue-router原理
vue-router通过hash和history两种方式实现前端路由更新视图但不重新请求页面是前段路由原理的核心之一

路由跳转传参：
params和query：this.$route.query.name和this.$route.params.name

Data为什么是一个函数
是为了在重复创建实例的时候避免共享同一数据，造成数据污染


vue常用的修饰符
trim 输入框过滤收尾空格
number 先输入数字就会限制只能输入数字
lazy 输入框改变数据就改变 lazy在逛遍离开input才更新数据
事件修饰符：
stop阻止点击事件冒泡，相当于原生js中的event，stopPropagation（）
.prevent防止执行预设的行为 ，相当于原生js中event.preventDefault() 
.capture添加事件侦听器时使用事件捕获模式，就是谁有该事件修饰符，就先触发睡谁。
.self只会触法自己范围内的事件，不包括子元素
.once只执行一次


vue的跨域解决方式
1.更改后台的header
2.使用jq提供jsonp
3.用http-proxy-middleware（配置代理服务器）

如何利用es6快速的去重？
let arr = [23, 12, 13, 33, 22, 12, 21]
let item = [...new Set(arr)]

vue中的data为什么是一个函数
简单来说，就是为了保证组件的独立性和可复用性，如果 data 是个函数的话，
每复用一次组件就会返回新的 data，类似于给每个组件实例创建一个私有的数据空间，保护各自的数据互不影响




